MIAL Specification

Mial is a machine independent target code for MCPL, based on the Sial
target code for BCPL. It consists of a stream of directives and
instructions composed of opcodes and operands. Both opcodes and
operands and encoded by integers. Each integer is prefixed by a
(redundant) letter specifying what kind of value it represents. These
prefixes are as follows:

F    An opcode or directive
P    A stack offset
G    A global variable number
K    A 24 bit unsigned constant, often small in value
W    A 32 bit signed integer
C    A string character in range 0..255
L    A label generated by TRN
M    A label generated by CG

The opcodes and directives are as follows:

Mnemonic  Operands   Meaning

lp        Pn         a := P!n
lg        Gn         a := G!n
ll        Ln         a := !Ln

llp       Pn         a := @ P!n
llg       Gn         a := @ G!n
lll       Ln         a := @ !Ln
lf        Ln         a := address of Ln, a function entry point

l         Kn         a := n         (n is a 24 bit integer)
lm        Kn         a := - n 
lw        Mn         a := !Mn       (load a large constant)

sp        Pn         P!n := a
sg        Gn         G!n := a
sl        Ln         !Ln := a

ap        Pn         a := a + P!n
ag        Gn         a := a + G!n
a         Kn         a := a + n
s         Kn         a := a - n

lkp       Kk Pn      a := P!n!k
lkg       Kk Gn      a := G!n!k
rv                   a := ! a
rvp       Pn         a := P!n!a
rvk       Kk         a := a!k
st                   !a := b
stp       Pn         P!n!a := b
stk       Kn         a!n := b
stkp      Kk Pn      P!n!k := a
stkg      Kk Gn      G!n!k := a
xst                  !b := a
stb                  %b := a
lvind                a := @ b!a
indb                 a := b%a
indb0                a := %a
indw                 a := b!a

k         Pn         Call  a(b,...) incrementing P by n
kpg       Pn Gg      Call Gg(a,...) incrementing P by n

neg                  a := - a
not                  a := ~ a       (bitwise not)
abs                  a := ABS a

xdiv                 a := a / b
xmod                 a := a MOD b
xsub                 a := a - b

mul                  a := b * a
div                  a := b / a
mod                  a := b MOD a
add                  a := b + a
sub                  a := b - a

eq                   a := b = a
ne                   a := b ~= a
ls                   a := b < a
gr                   a := b > a
le                   a := b <= a
ge                   a := b >= a
eq0                  a := a = 0
ne0                  a := a ~= 0
ls0                  a := a < 0
gr0                  a := a > 0
le0                  a := a <= 0
ge0                  a := a >= 0

lsh                  a := b << a
rsh                  a := b >> a
and                  a := b & a
or                   a := b | a
xor                  a := b XOR a
lshk      Kk         a := a << k
rshk      Kk         a := a >> k
 
xch                  swap a and b
atb                  b := a
atc                  c := a
cta                  a := c
bta                  a := b
btc                  c := b
atblp     Pn         b := a; a := P!n
atblg     Gn         b := a; a := G!n
atbl      Kk         b := a; a := k

j         Ln         jump to Ln
rtn                  procedure return

ikp       Kk Pn      a := P!n + k; P!n := a
ikg       Kk Gn      a := G!n + k; G!n := a
ikl       Kk Ln      a := !Ln + k; !Ln := a
ip        Pn         a := P!n + a; P!n := a
ig        Gn         a := G!n + a; G!n := a
il        Ln         a := !Ln + a; !Ln := a

jeq       Ln         Jump to Ln if b = a
jne       Ln         Jump to Ln if b ~= a
jls       Ln         Jump to Ln if b < a
jgr       Ln         Jump to Ln if b > a
jle       Ln         Jump to Ln if b <= a
jge       Ln         Jump to Ln if b >= a
jeq0      Ln         Jump to Ln if a = 0
jne0      Ln         Jump to Ln if a ~= 0
jls0      Ln         Jump to Ln if a < 0
jgr0      Ln         Jump to Ln if a > 0
jle0      Ln         Jump to Ln if a <= 0
jge0      Ln         Jump to Ln if a >= 0

brk                  Breakpoint instruction
nop                  No operation
chgco                Change coroutine
mdiv                 a := Muldiv(P!3, P!4, P!5)
sys                  System function

module    Kn C1 ... Cn         Name of module
modstart                       Start of module 
modend                         End of module
global    Kn G1 L1 ... Gn Ln   Global initialisation data
const     Mn Ww                Large integer constant (used by lw)
lab       Lm                   Program label
entry     Kn C1 ... Cn         Start of a function

dlab      Ln                   Set label to address of next static word
dw        Wn                   Allocate static word
db        Kn                   Allocate static byte
dl        Ln                   Allocate static pointer
ds        Kn                   Declare static space

hand      Ln                   Declare a handler
                               a!0, a!1, a!2 := P, H, Lm
                               H := a
                               
unh                            Remove a handler
                               H := H!1

raise                          Raise an exception
                               LET p, h, l := H!0, H!1, H!2
                               H!0, H!1, H!2 := a, b, c
                               P, H := p, h
                               GOTO l


M. Richards
23 May 1997

